# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Downloads test binaries and executes tests using dotnet vstest,
# runs the tests for each project on a background job in parallel,
# then uploads the results to Azure DevOps pipelines

parameters:
  osName: 'Windows' # The name of the operating system for display purposes.
  testTargetFrameworks: '' # A semicolon separated list of target frameworks indicating which frameworks tests will be run on. See: https://docs.microsoft.com/en-us/dotnet/standard/frameworks.
  binaryArtifactName: 'testbinaries' # The name of the Azure DevOps build artifact where the test assemblies will be downloaded from. Default 'testbinaries'.
  testResultsArtifactName: 'testresults' # The name of the Azure DevOps build artifact where the test results will be published. Default 'testresults'.
  vsTestPlatform: 'x64' # Target platform architecture used for test execution. Valid values are x86, x64, and ARM.
  testBinaryFilesConvention: '**/*.Tests*.dll' # The glob pattern (within $(System.DefaultWorkingDirectory)/**/<TargetFramework>/) where to look for test .dll files, so they can be distinguished from other .dll file types.
  maximumParallelJobs: 8

steps:
- powershell: |
    function EnsureNotNullOrEmpty([string]$param, [string]$nameOfParam) {
        if ([string]::IsNullOrEmpty($param)) {
            Write-Host "##vso[task.logissue type=error;]Missing template parameter \"$nameOfParam\""
            Write-Host "##vso[task.complete result=Failed;]"
        }
    }
    EnsureNotNullOrEmpty('${{ parameters.osName }}', 'osName')
    EnsureNotNullOrEmpty('${{ parameters.testTargetFrameworks }}', 'testTargetFrameworks')
    EnsureNotNullOrEmpty('${{ parameters.binaryArtifactName }}', 'binaryArtifactName')
    EnsureNotNullOrEmpty('${{ parameters.testResultsArtifactName }}', 'testResultsArtifactName')
    EnsureNotNullOrEmpty('${{ parameters.vsTestPlatform }}', 'vsTestPlatform')
    EnsureNotNullOrEmpty('${{ parameters.testBinaryFilesConvention }}', 'testBinaryFilesConvention')
  displayName: 'Validate Template Parameters'

- task: DownloadBuildArtifacts@0
  displayName: 'Download Build Artifacts: ${{ parameters.binaryArtifactName }}'
  inputs:
    artifactName: ${{ parameters.binaryArtifactName }}
    downloadPath: '$(System.DefaultWorkingDirectory)'

- powershell: |
    $testTargetFrameworksString = '${{ parameters.testTargetFrameworks }}'
    $testBinaryRootDirectory = "$(System.DefaultWorkingDirectory)"
    $testResultsArtifactDirectory = "${{ format('$(Build.ArtifactStagingDirectory)/{0}',parameters.testResultsArtifactName) }}"
    $testPlatform = '${{ parameters.vsTestPlatform }}'
    $testOSName = '${{ parameters.osName }}'
    $testBinaryFilesConvention = '${{ parameters.testBinaryFilesConvention }}'
    $maximumParalellJobs = '${{ parameters.maximumParallelJobs }}'
    $testTargetFrameworks = $testTargetFrameworksString.Split([char]',',[char]';')
    
    function SeparateVersionDigits([string]$digits) {
        return (&{ for ($i = 0;$i -lt $digits.Length;$i++) { $digits.Substring($i,1) }}) -join '.'
    }
    
    # Convert $framework (i.e. net461) into format for dotnet vstest (i.e. .NETFramework,Version=4.6.1)
    function ConvertFrameworkName([string]$framework) {
        $match = [regex]::Match($framework, '^net(\d+)$') # .NET Framework
        if ($match.Success) {
            $ver = SeparateVersionDigits($match.Groups[1].Value)
            return ".NETFramework,Version=v$($ver)"
        }
        $match = [regex]::Match($framework, '^netcoreapp(\d+\.\d+(?:\.\d+)?)$') # .NET Core
        if ($match.Success) {
            $ver = $match.Groups[1].Value
            return ".NETCoreApp,Version=v$($ver)"
        } 
        $match = [regex]::Match($framework, '^uap(\d+\.\d+)?$') # Universal Windows Platform
        if ($match.Success) {
            $ver = $match.Groups[1].Value
            $ver = if ([string]::IsNullOrEmpty($ver)) { '10' } else { $ver.Replace('.0','').Replace('.','') }
            return "FrameworkUap$($ver)"
        }
        return $framework
    }
    
    function IsSupportedFramework([string]$framework) {
        if ($IsWindows -eq $null) {
            $IsWindows = $env:OS.StartsWith('Win')
        }
        if (!$IsWindows -and !$framework.StartsWith('netcoreapp')) {
            return $false
        }
        return $true
    }
    
    foreach ($framework in $testTargetFrameworks) {
        if (!(IsSupportedFramework($framework))) { continue }
        $testBinaries = Get-ChildItem -Path "$testBinaryRootDirectory/**/$framework/$testBinaryFilesConvention" -Recurse 
        foreach ($testBinary in $testBinaries) {
            # Pause if we have queued too many parallel jobs
            $running = @(Get-Job | Where-Object { $_.State -eq 'Running' })
            if ($running.Count -ge $maximumParalellJobs) {
                $running | Wait-Job
            }

            $projectName = [System.IO.Path]::GetFileNameWithoutExtension($testBinary)
            # Special case - our CLI tool only supports .NET Core 2.1
            if ($projectName.Contains("Tests.Cli") -and (!$framework.StartsWith("netcoreapp2."))) {
                continue
            }

            $fwork = ConvertFrameworkName($framework)
            $combinedTestInfo = "$framework-$testOSName-$projectName"

            $scriptBlock = {
                param([string]$testBinary, [string]$fwork, [string]$combinedTestInfo, [string]$testPlatform, [string]$testResultsArtifactDirectory)
                Write-Host "Testing '$testBinary' on framework '$fwork'..."
                dotnet vstest "$testBinary" --Framework:"$fwork" --Platform:"$testPlatform" --Blame --logger:"trx;LogFileName=$testResultsArtifactDirectory/TEST-$combinedTestInfo.trx" > "$testResultsArtifactDirectory/$combinedTestInfo-dotnet-vstest.log" 2> "$testResultsArtifactDirectory/$combinedTestInfo-dotnet-vstest-error.log"
            }

            # Execute the jobs in parallel
            Start-Job $scriptBlock -ArgumentList $testBinary,$fwork,$combinedTestInfo,$testPlatform,$testResultsArtifactDirectory
        }
    }

    # Wait for it all to complete
    While (Get-Job -State "Running") {
        Start-Sleep 10
    }
  displayName: 'dotnet vstest ${{ parameters.testTargetFrameworks }}'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact: ${{ parameters.testResultsArtifactName }}'
  inputs:
    PathtoPublish: ${{ format('$(Build.ArtifactStagingDirectory)/{0}',parameters.testResultsArtifactName) }}
    ArtifactName: ${{ parameters.testResultsArtifactName }}
  condition: succeededOrFailed()

# Due to the fact that it is not possible to loop a task and
# it would be a ton of work to make a replacement for the
# Publish Test Results task or the (deprecated) TfsPublisher
# our only other option is to make a task for every supported
# platform and update it whenever a new platform is created by MS

# .NET Framework
- template: 'publish-test-results.yml'
  parameters:
    framework: net35
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net40
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net403
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net45
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net451
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net452
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net46
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net461
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net462
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net47
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net471
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net472
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: net48
    osName: ${{ parameters.osName }}

# .NET Core
- template: 'publish-test-results.yml'
  parameters:
    framework: netcoreapp1.0
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: netcoreapp1.1
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: netcoreapp2.0
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: netcoreapp2.1
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: netcoreapp2.2
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: netcoreapp3.0
    osName: ${{ parameters.osName }}

# Universal Windows Platform
- template: 'publish-test-results.yml'
  parameters:
    framework: uap
    osName: ${{ parameters.osName }}

- template: 'publish-test-results.yml'
  parameters:
    framework: uap10.0
    osName: ${{ parameters.osName }}